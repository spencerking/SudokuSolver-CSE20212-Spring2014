Spencer King, Lab 6 Sudoku Solver, Report, 3/06/2014

	This program is very easy for the user to use. After running the makefile, the user types "./main filename.txt" where filename.txt is the name of the file containing the puzzle the user wishes to solve. After entering this command, the program outputs the unsolved puzzle followed by the solved version. The user will be notified if there is a problem reading in their puzzle.

	Internally, this program is very similar to last week's sudoku lab, because of this the report will be a modified version of last week's report. 

	In main, the program checks to see if the user provided input when running the program. If the user did not, the program prints out the appropriate syntax for loading input. If the user did, the filename is passed into the instantiated puzzle object. This solver is only meant to be used with 9x9 puzzles and thus the number of lines is assumed to be 9. After this, the file containing the board is opened. The puzzle board and the 3d solution board are then resized based on the number of lines. After this is a set of nested for loops to run through the entire board. The file is read into a temporary int value named tmpInt. If this can not be done, the user is told there was a problem reading the file. If it is completed successfully, the integer values are added to the puzzle board vector using push_back. When I defined my two-dimensional vector I used two typedefs. One to name a vector of ints, and another to name a vector of a vector of ints. After doing this I was able to treat the 2d vector like a regular C-style array. I used the same principles for the 3d vector. This made it very easy to add data. Originally I had been attempting to use push_back to add a temporary vector into my 2d array. While doing this I encountered multiple segfaults and could not get it to work properly. In the end, this proved to be an easier method. The last thing my non-default constructor does is initialize the 3d solution board. Three nested for loops run through the entire board and push the values 1 through 9 into every position in the 3rd dimension. This is used for all the possible values for each position, and initially all values are possible. 

	Next, main calls the print function. This function uses nested for loops to run through the vector and print out the puzzle board. If a 0 is found, a space is printed instead so that the user can clearly see where numbers still need to be added. I was able to print the puzzle board the same way I would have printed out an array in a C program.

	Main then enters a while loop that calls the solve function. The solve function starts with two nested for loops to run through an entire sudoku board and uses them to repeatedly call the check function. The check function takes in an x and y coordinate and first ensures that there is not already a number in that position on the puzzle board. If there is, the solution board is set to 0, as there are no possible values to be added. After this are two loops to check the rows and columns for possible values. If values found in the row or column match values found in the the solution board, those values are set to 0 in the solution board. This is because those values are already present in the row or column and thus cannot occur again. The same concept is applied to the mini grids. 
	
	After this, the solve function checks for single values. Three nested for loops are used to run through the entire board and in all spaces where there is only one possible value, that value is placed. Everytime a non-zero value is found, a variable is set equal to that value and a counter value is incremented by 1. After checking all possible values for that spot if the counter is 1, the value is placed on the board since only one non-zero value was found for that position. After this the counter is set equal to zero and this process is repeated for the next spot on the board. After this a similar logic is applied for the rows, columns, and mini-grids. 

	Main then calls the checkDone function. This function runs through the solution board and checks to see if there are any non-zero values in the 3rd dimension. If there are, the function returns a 0 since there are still values to place on the board and the while loop will continue. If no non-zero values are found, the function returns a 1 meaning the solution is complete. Once the loop ends the completed puzzle board is printed. 

	I verified the program by using the easy, medium, and cc1 txt files posted on Piazza. For the easy and medium puzzles my program's solution matched those posted on Piazza. My result for cc1 matched what I got from an online solver, which I assume is correct. I also tested each check on simple puzzles I created and the correct values were filled in every time. 

	Like in last week's lab, I found that typedefs were very helpful as I kept getting seg faults when trying to define and fill my vectors without using typedefs. I had also originally attempted to delete values that were not possible from the solution board. I ran into significant difficulty using the erase function and decided it was easier to just set values to 0. It is also easier to set up for loops as they were all always running either from 1 to 9 or 0 to 8. If I was deleting values I would have to account for the variable size of specific elements in the vector. In the end, it seemed simpler to me to just keep track of the 0 values. 
